id: code/refactor
name: Code Refactoring
description: Intelligent code refactoring with pattern recognition, transformation suggestions, and automated restructuring.
version: "0.1.0"
category: code
level: intermediate

tags:
  - refactoring
  - clean-code
  - patterns
  - transformation
  - restructuring

dependencies:
  - skill_id: code/review
    optional: true
    reason: Pre-refactor quality check

requires_tools: []

estimated_tokens: 700

author: CLI AI Team
license: MIT

examples:
  - input:
      code: |
        def process(data):
            result = []
            for item in data:
                if item is not None:
                    if item > 0:
                        result.append(item * 2)
            return result
      refactor_type: simplify
    output:
      refactored_code: |
        def process(data: list) -> list:
            """Process data by doubling positive non-None values."""
            return [item * 2 for item in data if item is not None and item > 0]
      changes:
        - type: simplify
          description: Converted nested if statements to list comprehension
        - type: enhance
          description: Added type hints and docstring
      improvement_score: 40

  - input:
      code: |
        class UserManager:
            def __init__(self):
                self.db = Database()
                self.cache = Cache()
                self.logger = Logger()
                self.validator = Validator()
                self.emailer = Emailer()

            def create_user(self, data):
                self.validator.validate(data)
                user = self.db.insert(data)
                self.cache.invalidate()
                self.logger.log(f"Created {user}")
                self.emailer.send_welcome(user)
                return user
      refactor_type: patterns
    output:
      suggestions:
        - pattern: Dependency Injection
          reason: Class creates its own dependencies, making testing difficult
          example: Accept dependencies in constructor
        - pattern: Single Responsibility
          reason: Class handles validation, persistence, caching, logging, and email
          example: Extract EmailNotifier, UserRepository classes
